// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"
	time "time"

	atc "github.com/concourse/concourse/atc"
	db "github.com/concourse/concourse/atc/db"
)

type FakeResourceCheck struct {
	FinishStub        func() error
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
	}
	finishReturns struct {
		result1 error
	}
	finishReturnsOnCall map[int]struct {
		result1 error
	}
	FinishWithErrorStub        func(string) error
	finishWithErrorMutex       sync.RWMutex
	finishWithErrorArgsForCall []struct {
		arg1 string
	}
	finishWithErrorReturns struct {
		result1 error
	}
	finishWithErrorReturnsOnCall map[int]struct {
		result1 error
	}
	FromVersionStub        func() atc.Version
	fromVersionMutex       sync.RWMutex
	fromVersionArgsForCall []struct {
	}
	fromVersionReturns struct {
		result1 atc.Version
	}
	fromVersionReturnsOnCall map[int]struct {
		result1 atc.Version
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	ResourceStub        func() (db.Resource, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
	}
	resourceReturns struct {
		result1 db.Resource
		result2 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 error
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	TimeoutStub        func() time.Duration
	timeoutMutex       sync.RWMutex
	timeoutArgsForCall []struct {
	}
	timeoutReturns struct {
		result1 time.Duration
	}
	timeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceCheck) Finish() error {
	fake.finishMutex.Lock()
	ret, specificReturn := fake.finishReturnsOnCall[len(fake.finishArgsForCall)]
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
	}{})
	fake.recordInvocation("Finish", []interface{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeResourceCheck) FinishCalls(stub func() error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = stub
}

func (fake *FakeResourceCheck) FinishReturns(result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) FinishReturnsOnCall(i int, result1 error) {
	fake.finishMutex.Lock()
	defer fake.finishMutex.Unlock()
	fake.FinishStub = nil
	if fake.finishReturnsOnCall == nil {
		fake.finishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) FinishWithError(arg1 string) error {
	fake.finishWithErrorMutex.Lock()
	ret, specificReturn := fake.finishWithErrorReturnsOnCall[len(fake.finishWithErrorArgsForCall)]
	fake.finishWithErrorArgsForCall = append(fake.finishWithErrorArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FinishWithError", []interface{}{arg1})
	fake.finishWithErrorMutex.Unlock()
	if fake.FinishWithErrorStub != nil {
		return fake.FinishWithErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.finishWithErrorReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) FinishWithErrorCallCount() int {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	return len(fake.finishWithErrorArgsForCall)
}

func (fake *FakeResourceCheck) FinishWithErrorCalls(stub func(string) error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = stub
}

func (fake *FakeResourceCheck) FinishWithErrorArgsForCall(i int) string {
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	argsForCall := fake.finishWithErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceCheck) FinishWithErrorReturns(result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	fake.finishWithErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) FinishWithErrorReturnsOnCall(i int, result1 error) {
	fake.finishWithErrorMutex.Lock()
	defer fake.finishWithErrorMutex.Unlock()
	fake.FinishWithErrorStub = nil
	if fake.finishWithErrorReturnsOnCall == nil {
		fake.finishWithErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.finishWithErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) FromVersion() atc.Version {
	fake.fromVersionMutex.Lock()
	ret, specificReturn := fake.fromVersionReturnsOnCall[len(fake.fromVersionArgsForCall)]
	fake.fromVersionArgsForCall = append(fake.fromVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("FromVersion", []interface{}{})
	fake.fromVersionMutex.Unlock()
	if fake.FromVersionStub != nil {
		return fake.FromVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fromVersionReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) FromVersionCallCount() int {
	fake.fromVersionMutex.RLock()
	defer fake.fromVersionMutex.RUnlock()
	return len(fake.fromVersionArgsForCall)
}

func (fake *FakeResourceCheck) FromVersionCalls(stub func() atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = stub
}

func (fake *FakeResourceCheck) FromVersionReturns(result1 atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = nil
	fake.fromVersionReturns = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResourceCheck) FromVersionReturnsOnCall(i int, result1 atc.Version) {
	fake.fromVersionMutex.Lock()
	defer fake.fromVersionMutex.Unlock()
	fake.FromVersionStub = nil
	if fake.fromVersionReturnsOnCall == nil {
		fake.fromVersionReturnsOnCall = make(map[int]struct {
			result1 atc.Version
		})
	}
	fake.fromVersionReturnsOnCall[i] = struct {
		result1 atc.Version
	}{result1}
}

func (fake *FakeResourceCheck) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeResourceCheck) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeResourceCheck) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceCheck) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceCheck) Resource() (db.Resource, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
	}{})
	fake.recordInvocation("Resource", []interface{}{})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceCheck) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakeResourceCheck) ResourceCalls(stub func() (db.Resource, error)) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakeResourceCheck) ResourceReturns(result1 db.Resource, result2 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceCheck) ResourceReturnsOnCall(i int, result1 db.Resource, result2 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceCheck) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeResourceCheck) StartCalls(stub func() error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeResourceCheck) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceCheck) Timeout() time.Duration {
	fake.timeoutMutex.Lock()
	ret, specificReturn := fake.timeoutReturnsOnCall[len(fake.timeoutArgsForCall)]
	fake.timeoutArgsForCall = append(fake.timeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("Timeout", []interface{}{})
	fake.timeoutMutex.Unlock()
	if fake.TimeoutStub != nil {
		return fake.TimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.timeoutReturns
	return fakeReturns.result1
}

func (fake *FakeResourceCheck) TimeoutCallCount() int {
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	return len(fake.timeoutArgsForCall)
}

func (fake *FakeResourceCheck) TimeoutCalls(stub func() time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = stub
}

func (fake *FakeResourceCheck) TimeoutReturns(result1 time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = nil
	fake.timeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeResourceCheck) TimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.timeoutMutex.Lock()
	defer fake.timeoutMutex.Unlock()
	fake.TimeoutStub = nil
	if fake.timeoutReturnsOnCall == nil {
		fake.timeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.timeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeResourceCheck) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.finishWithErrorMutex.RLock()
	defer fake.finishWithErrorMutex.RUnlock()
	fake.fromVersionMutex.RLock()
	defer fake.fromVersionMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceCheck) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ResourceCheck = new(FakeResourceCheck)
